#define _POSIX_SOURCE
/* Cpp inlcudes */
#include <iostream>
#include <vector>
/* C & linux incldues */
#include <unistd.h>
#include <sys/types.h>
#include <string.h>
#include <poll.h>
#include <pthread.h>
/* Dependencies */
#include "networking.h"
#include "cardlib.h"
using namespace std;

/* Globals */
Deck *deck;
Deck *playing_deck = new Deck(1);
Server *my_server;
pthread_mutex_t mutex;


/* Never used, hear because of other bad code */
void handle_server_msg ()
{
  return;
}


//Maps cards to index of playing card deck
//Returns index on success and -1 on error
int map_card ( char key )
{
  switch ( key )
    {
    case '1':
      return 0;
    case '2':
      return 1;
    case '3':
      return 2;
    case '4':
      return 3;
    case 'Q':
      return 4;
    case 'W':
      return 5;
    case 'E':
      return 6;
    case 'R':
      return 7;
    case 'A':
      return 8;
    case 'S':
      return 9;
    case 'D':
      return 10;
    case 'F':
      return 11;
/*Required if client list is extended to 16
    case 'Z':
      return 12;
    case 'X':  
      return 13;
    case 'C':
      return 14;
    case 'V':
      return 15;
*/
    default:
      return -1;
    }
}

// Sends desired amount of cards to all clients.
void send_playing_cards (  ) 
{ 
  int cards_needed = 12;
  string cards_to_send = create_playing_cards ( cards_needed, deck, playing_deck );
  for ( auto client_it : my_server->get_client_list() )
  {
    my_server->sendMessage( client_it.sock_fd, 'c', cards_to_send ); 
  }
}


<<<<<<< HEAD
=======
void respond_to_client ( int client_sock_fd, char* guess )
{
 
  sendMessage( client_sock_fd, 'm', "Checking guess.." ); 
  
  //Set to check
  vector<Card*>cset;
  
 
  cset.push_back( playing_deck->get_card( map_card( guess[0] ) ) );
  cset.push_back( playing_deck->get_card( map_card( guess[1] ) ) );
  cset.push_back( playing_deck->get_card( map_card( guess[2] ) ) );

  //Display set info -- Testing purposes
  display_card( cset[0] );
  display_card( cset[1] );
  display_card( cset[2] );
  

  //Client Guess - True
  if ( check_set ( cset ) )
    {
      sendMessage( client_sock_fd, 'm',  "This is where Greg does the truth magic" );
    }

  //Client Guess - False
  else
    {
      sendMessage( client_sock_fd, 'm', "Naw client, thats not a set" );
    }
}


void *wait_for_client ( void *arg )
{
  for (;;)
  {
    // will need to be edited for mulithreading
    // currently just connects one client
    // auto client_it = client_list.push_back( client_list.begin(), Client{});
    // emplace might be replacing, check when implementing multiple client
    Client this_client = {};
    socklen_t client_len = sizeof (this_client.addr);
    this_client.sock_fd = accept(server_sock_fd,
                                    (struct sockaddr *) &this_client.addr,
                                    &client_len );

    if ( this_client.sock_fd < 0 )
    {
      die("Error on accept. ");
    }
    else
    {
      cout << "Connected new client." << endl;

      // add poll fd and send message
      struct pollfd client_sock_fd = {this_client.sock_fd, POLLIN, 0};

      // CRITICAL SECTION
      pthread_mutex_lock(&mutex);
      poll_fds.push_back(client_sock_fd);
      client_list.push_back( this_client );
      pthread_mutex_unlock(&mutex);

      sendMessage( this_client.sock_fd, 'm', "You have been connected.");
      send_playing_cards( );
      //sendMessage( this_client.sock_fd, 'c', "" + deck->cards[0]->bitcode );
    }
  }

  return arg;
}

>>>>>>> d65858d05522cef530f0acf51cda02dd73c8f8b6

void display_options ( )
{
  cout << "Q. Quit" << endl;
  cout << "D. Display deck" << endl;
  cout << "S. Shuffle deck" << endl;
  cout << "A. Memory Addresses" << endl;
  cout << "W. Draw card"<< endl;
  cout << "P. Print Playing Cards" << endl;
}


void handle_input()
{
  char type = 0;
  string inp = {};

  cin >> inp;
  type = inp[0];
  cout << type << endl;
  switch( toupper( type ) )
  {
    case 'Q':
      {
        my_server->cleanup();
      }
      break;

    case 'D':
      {
        deck->display( 0 );
      }
      break;
      
    case 'S':
      {
        cout<<"shuffling..."<<endl;
        deck->shuffle();
      }
      break;

    case 'A':
      {
        deck->mem_display();
      }
      break;
    
    case 'W':
      {
        Card *ncard = deck->draw();
        playing_deck->add_card( ncard );
        
        cout << "Drew card:" << endl;
        cout << "Symbol:" << ncard->symbol << " Shade:" << ncard->shade << " Color:" << ncard->color << " Number:" << ncard->number << endl;
      }
      break;

    case 'P':
      {
        string card_array;
        int cards_needed;

        cout << "cards needed?" <<endl;
        cin >> cards_needed;
        
        card_array = create_playing_cards( cards_needed, deck, playing_deck );
        cout << card_array << endl;

        playing_deck->display( 1 );
      }
      break;

    default:
      break;
  }
}


void *wait_for_client_wrap ( void *arg )
{
  my_server->wait_for_client();

  return arg;
}


void sig_wrap_cleanup ( int sig )
{
  my_server->cleanup();
}


int main(int argc, char* argv[])
{
  deck = new Deck();
  char LOCALHOST[] = "127.0.0.1";
  
  //Shuffle Deck 
  deck->shuffle();
  deck->shuffle();

  if ( argc ==1 || argc > 3 )
  {
    my_server->die("Usage: ./server <port>");
  }
  else
  {
    if ( argc == 2) // No port number given
    {
      my_server = new Server( atoi( argv[1] ), LOCALHOST );
    }

    if ( argc == 3) // Addr and Port Given
    {
      my_server = new Server( atoi( argv[1] ), argv[2] );
    }
  }

  // bind TERM to cleanup
  struct sigaction action = {};

  action.sa_handler = sig_wrap_cleanup;
  sigaction( SIGINT, &action, nullptr );
  
  pthread_t thread;
  if ( pthread_create( &thread, NULL, wait_for_client_wrap, nullptr ) != 0 )
  {
    my_server->die( "Couldn't start wait for client" );
  }
  pthread_detach( thread );

  my_server->wait_for_input();
  my_server->cleanup();
}

